apiVersion: v1
kind: ConfigMap
metadata:
  name: {{ include "ibm-portworx.fullname" . }}
  annotations:
    argocd.argoproj.io/sync-wave: "-5"
  labels:
    {{- include "ibm-portworx.labels" . | nindent 4 }}
data:
  volume-attach.sh: |+
    #!/usr/bin/env bash

    NODE_NAME="$1"
    RESOURCE_GROUP_ID="$2"

    if [[ -z "${NODE_NAME}" ]] || [[ -z "${RESOURCE_GROUP_ID}" ]]; then
      echo "usage: attach-volume.sh NODE_NAME RESOURCE_GROUP_ID" >&2
      exit 1
    fi

    if [[ -z "${IBMCLOUD_API_KEY}" ]]; then
      echo "IBMCLOUD_API_KEY must be provided as an environment variable" >&2
      exit 1
    fi

    if ! command -v curl 1> /dev/null 2> /dev/null; then
      echo "curl command not found" >&2
      exit 1
    fi

    if ! command -v jq 1> /dev/null 2> /dev/null; then
      echo "jq command not found" >&2
      exit 1
    fi

    if ! command -v kubectl 1> /dev/null 2> /dev/null; then
      echo "kubectl command not found" >&2
      exit 1
    fi

    REGION=$(kubectl get node "${NODE_NAME}" -o json | jq -r '.metadata.labels["ibm-cloud.kubernetes.io/region"]')
    WORKER_ID=$(kubectl get node "${NODE_NAME}" -o json | jq -r '.metadata.labels["ibm-cloud.kubernetes.io/worker-id"]')
    PROVIDER_ID=$(kubectl get node "${NODE_NAME}" -o json | jq -r '.spec.providerID')
    CLUSTER_ID=$(echo "${PROVIDER_ID}" | sed -E 's~ibm://.*/([^/]+)/.+~\1~g')

    NAME="pwx-${WORKER_ID}"

    export TOKEN=$(curl -s -X POST "https://iam.cloud.ibm.com/identity/token" \
      -H "Content-Type: application/x-www-form-urlencoded" \
      -d "grant_type=urn:ibm:params:oauth:grant-type:apikey&apikey=${IBMCLOUD_API_KEY}" | jq -r '.access_token')

    API_VERSION="2021-04-06"

    VOLUME_ID=$(curl -X GET "https://${REGION}.iaas.cloud.ibm.com/v1/volumes?version=${API_VERSION}&generation=2" \
      -H "Authorization: ${TOKEN}" | \
      jq -r --arg NAME "${NAME}" '.volumes[] | select(.name == $NAME) | .id // empty')

    # Before creating, check to see if attachment for volume is already present
    if ! RESPONSE=$(curl -s -X GET \
            -H "Authorization: ${TOKEN}" \
            -H "Content-Type: application/json" \
            -H "X-Auth-Resource-Group-ID: ${RESOURCE_GROUP_ID}" \
            "https://${REGION}.containers.cloud.ibm.com/v2/storage/getAttachments?cluster=${CLUSTER_ID}&worker=${WORKER_ID}"
    ); then
      echo "Error when trying to /getAttachments" >&2
      exit 1
    fi

    ID=$(echo "${RESPONSE}" | jq -r --arg VOLUME_ID "$VOLUME_ID" '.volume_attachments[] | select(.volume.id==$VOLUME_ID) | .id // empty')

    if [[ -z "${ID}" ]]; then
        if ! RESPONSE=$(
            curl -s -X POST "https://containers.cloud.ibm.com/global/v2/storage/createAttachment" \
              -H "accept: application/json" \
              -H "Authorization: ${TOKEN}" \
              -H "X-Auth-Resource-Group-ID: ${RESOURCE_GROUP_ID}" \
              -H "Content-Type: application/json" \
              -d "{  \"cluster\": \"${CLUSTER_ID}\",  \"volumeID\": \"${VOLUME_ID}\",  \"worker\": \"${WORKER_ID}\" }"
        ); then
          echo "Error when trying to /createAttachment"
          exit 1
        fi

        ID=$(echo "${RESPONSE}" | jq -r '.id // empty')

        if [[ -z "${ID}" ]]; then
            echo "/createAttachment did not work: ${RESPONSE}" >&2
            exit 1
        fi

        echo "Created attachment for ${CLUSTER_ID}, ${WORKER_ID} and ${VOLUME_ID}: ${ID}"
        echo 'Sleeping for 1 minute...'
        sleep 1m # it takes some seconds for the attachment to stabilize and propagate
    else
      echo "Attachment already exists: ${RESPONSE}"
    fi

  volume-attachment-destroy.sh: |
    #!/bin/bash

    NODE_NAME="$1"
    RESOURCE_GROUP_ID="$2"

    if [[ -z "${NODE_NAME}" ]] || [[ -z "${RESOURCE_GROUP_ID}" ]]; then
      echo "usage: attach-volume.sh NODE_NAME RESOURCE_GROUP_ID" >&2
      exit 1
    fi

    if [[ -z "${IBMCLOUD_API_KEY}" ]]; then
      echo "IBMCLOUD_API_KEY must be provided as an environment variable" >&2
      exit 1
    fi

    if ! command -v curl 1> /dev/null 2> /dev/null; then
      echo "curl command not found" >&2
      exit 1
    fi

    if ! command -v jq 1> /dev/null 2> /dev/null; then
      echo "jq command not found" >&2
      exit 1
    fi

    if ! command -v kubectl 1> /dev/null 2> /dev/null; then
      echo "kubectl command not found" >&2
      exit 1
    fi

    REGION=$(kubectl get node "${NODE_NAME}" -o json | jq -r '.metadata.labels["ibm-cloud.kubernetes.io/region"]')
    WORKER_ID=$(kubectl get node "${NODE_NAME}" -o json | jq -r '.metadata.labels["ibm-cloud.kubernetes.io/worker-id"]')
    PROVIDER_ID=$(kubectl get node "${NODE_NAME}" -o json | jq -r '.spec.providerID')
    CLUSTER_ID=$(echo "${PROVIDER_ID}" | sed -E 's~ibm://.*/([^/]+)/.+~\1~g')

    NAME="pwx-${WORKER_ID}"

    export TOKEN=$(curl -s -X POST "https://iam.cloud.ibm.com/identity/token" \
      -H "Content-Type: application/x-www-form-urlencoded" \
      -d "grant_type=urn:ibm:params:oauth:grant-type:apikey&apikey=${IBMCLOUD_API_KEY}" | jq -r '.access_token')

    API_VERSION="2021-04-06"

    VOLUME_ID=$(curl -X GET "https://${REGION}.iaas.cloud.ibm.com/v1/volumes?version=${API_VERSION}&generation=2" \
      -H "Authorization: ${TOKEN}" | \
      jq -r --arg NAME "${NAME}" '.volumes[] | select(.name == $NAME) | .id // empty')

    echo "Detaching volume $VOLUME_ID from worker $WORKER_ID"

    # Grab volume attachment id
    if ! RESPONSE=$(
        curl -s -X GET -H "Authorization: $TOKEN" \
            -H "Content-Type: application/json" \
            -H "X-Auth-Resource-Group-ID: $RESOURCE_GROUP_ID" \
            "https://$REGION.containers.cloud.ibm.com/v2/storage/getAttachments?cluster=$CLUSTER_ID&worker=$WORKER_ID"
    ); then
      echo 'Error when trying to /getAttachments' >&2
      exit 1
    fi

    ID=$(echo "${RESPONSE}" | jq -r --arg VOLUMEID "$VOLUME_ID" '.volume_attachments[] | select(.volume.id==$VOLUMEID) | .id // empty')

    if [[ -z "${ID}" ]]; then
        echo "No attachment found, skipping"
    else
        echo "Deleting volume attachment $ID"
        if ! curl -s -X DELETE -H "Authorization: $TOKEN" \
            "https://$REGION.containers.cloud.ibm.com/v2/storage/vpc/deleteAttachment?cluster=$CLUSTER_ID&worker=$WORKER_ID&volumeAttachmentID=$ID"; then
          echo 'Delete failed' >&2
          exit 1
        fi
        echo 'Sleeping for 30s...'
        sleep 30
    fi
  volume-create.sh: |
    #!/usr/bin/env bash

    NODE_NAME="$1"
    RESOURCE_GROUP_ID="$2"

    if [[ -z "${NODE_NAME}" ]] || [[ -z "${RESOURCE_GROUP_ID}" ]]; then
      echo "usage: create-volume.sh NODE_NAME RESOURCE_GROUP_ID" >&2
      exit 1
    fi

    if [[ -z "${IBMCLOUD_API_KEY}" ]]; then
      echo "IBMCLOUD_API_KEY must be provided as an environment variable" >&2
      exit 1
    fi

    if ! command -v curl 1> /dev/null 2> /dev/null; then
      echo "curl command not found" > &2
      exit 1
    fi

    if ! command -v jq 1> /dev/null 2> /dev/null; then
      echo "jq command not found" > &2
      exit 1
    fi

    if ! command -v kubectl 1> /dev/null 2> /dev/null; then
      echo "kubectl command not found" > &2
      exit 1
    fi

    ## Lookup zone and resource group from the cluster
    REGION=$(kubectl get node "${NODE_NAME}" -o json | jq -r '.metadata.labels["ibm-cloud.kubernetes.io/region"]')
    ZONE=$(kubectl get node "${NODE_NAME}" -o json | jq -r '.metadata.labels["ibm-cloud.kubernetes.io/zone"]')
    WORKER_ID=$(kubectl get node "${NODE_NAME}" -o json | jq -r '.metadata.labels["ibm-cloud.kubernetes.io/worker-id"]')

    NAME="pwx-${WORKER_ID}"

    if [[ -z "${IOPS}" ]]; then
      IOPS="100"
      echo "IOPS environment variable not provided. Defaulting to '${IOPS}'"
    fi
    if [[ -z "${CAPACITY}" ]]; then
      CAPACITY="50"
      echo "CAPACITY environment variable not provided. Defaulting to '${CAPACITY}'"
    fi
    if [[ -z "${PROFILE}" ]]; then
      PROFILE="custom"
      echo "PROFILE environment variable not provided. Defaulting to '${PROFILE}'"
    fi
    if [[ -z "${ENCRYPTION_KEY}" ]]; then
      echo "ENCRYPTION_KEY environment variable not provided. The volume won't be encrypted with KMS."
    fi

    jq -n \
      --arg NAME "${NAME}" \
      --arg ZONE "${ZONE}" \
      --arg RESOURCE_GROUP_ID "${RESOURCE_GROUP_ID}" \
      --arg IOPS "${IOPS}" \
      --arg CAPACITY "${CAPACITY}" \
      --arg PROFILE "${PROFILE}" \
      '{"name": $NAME, "iops": $IOPS, "capacity": $CAPACITY, "zone": {"name": $ZONE}, "profile": {"name": $PROFILE}, "resource_group": {"id": $RESOURCE_GROUP_ID}}' > /tmp/volume-request.json

    if [[ -n "${ENCRYPTION_KEY}" ]]; then
      cat /tmp/volume-request.json | jq --arg ENCRYPTION_KEY "${ENCRYPTION_KEY}" \
        '.encryption_key = {"crn": $ENCRYPTION_KEY}' > /tmp/volume-request.json.bak && \
        cp /tmp/volume-request.json.bak /tmp/volume-request.json && \
        rm /tmp/volume-request.json.bak
    fi

    VPC_API_ENDPOINT="https://${REGION}.iaas.cloud.ibm.com"
    API_VERSION="2021-04-06"

    export TOKEN=$(curl -s -X POST "https://iam.cloud.ibm.com/identity/token" \
      -H "Content-Type: application/x-www-form-urlencoded" \
      -d "grant_type=urn:ibm:params:oauth:grant-type:apikey&apikey=${IBMCLOUD_API_KEY}" | jq -r '.access_token')


    ## Check if volume already exists
    VOLUME_ID=$(curl -X GET "${VPC_API_ENDPOINT}/v1/volumes?version=${API_VERSION}&generation=2" \
      -H "Authorization: $TOKEN" | \
      jq -r --arg NAME "${NAME}" '.volumes[] | select(.name == $NAME) | .id // empty')

    if [[ -n "${VOLUME_ID}" ]]; then
      echo "Volume already exists: ${NAME}"
      exit 0
    fi

    curl -X POST "${VPC_API_ENDPOINT}/v1/volumes?version=${API_VERSION}&generation=2" \
      -H "Authorization: $TOKEN" \
      -d @/tmp/volume-request.json
  volume-manage.sh: |
    #!/usr/bin/env bash

    SCRIPT_DIR=$(cd $(dirname "$0"); pwd -P)

    export NODE_NAME="$1"
    export RESOURCE_GROUP_ID="$2"

    exit_script() {
        echo "SIGTERM received!"
        echo "Cleaning up volume attachment"
        "${SCRIPT_DIR}/volume-attachment-destroy.sh" "${NODE_NAME}" "${RESOURCE_GROUP_ID}"
    }

    trap exit_script SIGTERM

    "${SCRIPT_DIR}/volume-attach.sh" "${NODE_NAME}" "${RESOURCE_GROUP_ID}"

    while true; do sleep 300; done
  wipe_portworx.sh: "#!/bin/bash\n\n\n# Docs for cleaning up Portworx installation at: https://cloud.ibm.com/docs/containers?topic=containers-portworx#portworx_cleanup\n# Additional utilities for cleaning up Portworx installation available at https://github.com/IBM/ibmcloud-storage-utilities/blob/master/px-utils/px_cleanup/px-wipe.sh\n\necho \"Wiping Portworx from cluster: $CLUSTER\"\n\nPATH=$BIN_DIR:$PATH\n\ncurl  -fSsL https://raw.githubusercontent.com/IBM/ibmcloud-storage-utilities/master/px-utils/px_cleanup/px-wipe.sh | bash -s -- --talismanimage icr.io/ext/portworx/talisman --talismantag 1.1.0 --wiperimage icr.io/ext/portworx/px-node-wiper --wipertag 2.5.0 --force\n\necho \"removing the portworx helm from the cluster\"\n_rc=0\nhelm_release=$(helm ls -a --output json | jq -r '.[]|select(.name==\"portworx\") | .name')\nif [ -z \"$helm_release\" ];\nthen\n  echo \"Unable to find helm release for portworx.  Ensure your helm client is at version 3 and has access to the cluster.\";\nelse\n  helm uninstall portworx || _rc=$?\n  if [ $_rc -ne 0 ]; then\n    echo \"error removing the helm release\"\n    #exit 1;\n  fi\nfi\n\necho \"removing all portworx storage classes\"\nkubectl get sc -A | grep portworx | awk '{ print $1 }' > sc.tmp\nwhile read in; do\n  kubectl delete sc \"$in\"\ndone < sc.tmp\nrm -rf sc.tmp\n\necho \"removing portworx artifacts\"\nkubectl delete serviceaccount -n kube-system portworx-hook --ignore-not-found=true\nkubectl delete clusterrole -n kube-system portworx-hook --ignore-not-found=true\nkubectl delete clusterrolebinding -n kube-system portworx-hook --ignore-not-found=true\n\nkubectl delete Service portworx-service -n kube-system --ignore-not-found=true\nkubectl delete Service portworx-api -n kube-system --ignore-not-found=true\n\nkubectl delete serviceaccount -n kube-system portworx-hook --ignore-not-found=true \nkubectl delete clusterrole portworx-hook -n kube-system --ignore-not-found=true\nkubectl delete clusterrolebinding portworx-hook -n kube-system --ignore-not-found=true\n\nkubectl delete job -n kube-system talisman --ignore-not-found=true\nkubectl delete serviceaccount -n kube-system talisman-account --ignore-not-found=true \nkubectl delete clusterrolebinding talisman-role-binding --ignore-not-found=true \nkubectl delete crd volumeplacementstrategies.portworx.io --ignore-not-found=true\nkubectl delete configmap -n kube-system portworx-pvc-controller --ignore-not-found=true\n\nkubectl delete secret -n default sh.helm.release.v1.portworx.v1 --ignore-not-found=true\n\n# use the following command to verify all portworks resources are gone.  If you see a result here, it didn't work\n# kubectl get all -A | grep portworx"
  write-config-secret.sh: |
    #!/usr/bin/env bash

    NODE_NAME="$1"
    NAMESPACE="$2"
    SECRET_NAME="$3"

    PROVIDER_ID=$(oc get node "${NODE_NAME}" -o json | jq -r '.spec.providerID')
    CLUSTER_ID=$(echo "${PROVIDER_ID}" | sed -E 's~ibm://.*/([^/]+)/.+~\1~g')

    kubectl create secret generic "${SECRET_NAME}" \
      --from-literal="clusterId=${CLUSTER_ID}" \
      --dry-run=client \
      --output=json | \
      kubectl apply -n "${NAMESPACE}" -f -
